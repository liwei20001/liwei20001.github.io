<!doctype html>
<html lang="en-us">
  <head>
    <title>Test // My New Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.66.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://liwei20001.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Test"/>
<meta name="twitter:description" content="opencv-python 图像初阶 imread(filename, parameter) parameter=1,加载彩色图像, parameter=0,加载灰度图像
imshow(window_name, img) 显示图像
nameWindow(window_name, cv2.WINDOW_NORMAL) 新建一个窗口, cv2.WINDOW_NORMAL: 窗口可调节, 默认不可调节
plt.imshow(img) 在matplot中显示图像, matplotlib的图像通道为RGB而opencv的图像通道为BGR
视频入门 从相机捕获视频 cap = cv2.Videocapture(0) 调用摄像头,并创建摄像头对象
key = cv2.waitKey(0) &amp; 0xff 按键检测, 返回一个int类型数据, &lsquo;27&#39;为ESC, ord(&lsquo;q&rsquo;) 检测按键q
cap.release() 程序结束后,释放摄像头
cap.get(3)# 宽度 cap.get(4) #高度 cap.get(5) # 视频的帧率 读取相机的相关数据 cv2.destroyAllWindows() 关闭所有创建的窗口
cv2.destroyWindow(window_name) # 关闭指定的窗口
保存相机捕获视频 # 创建windows编译解码器并创建VideoWriter对象 fourcc = cv2.VideoWriter_fourcc(*&#39;XVID&#39;) out = cv2.VideoWriter(&#39;output.avi&#39;, fourcc, fps(float), (width, height)) # 逐帧将图片写入out中 out.write(frame) out.release() # 释放文件资源 opencv 绘图功能 基本画图 cv2."/>

    <meta property="og:title" content="Test" />
<meta property="og:description" content="opencv-python 图像初阶 imread(filename, parameter) parameter=1,加载彩色图像, parameter=0,加载灰度图像
imshow(window_name, img) 显示图像
nameWindow(window_name, cv2.WINDOW_NORMAL) 新建一个窗口, cv2.WINDOW_NORMAL: 窗口可调节, 默认不可调节
plt.imshow(img) 在matplot中显示图像, matplotlib的图像通道为RGB而opencv的图像通道为BGR
视频入门 从相机捕获视频 cap = cv2.Videocapture(0) 调用摄像头,并创建摄像头对象
key = cv2.waitKey(0) &amp; 0xff 按键检测, 返回一个int类型数据, &lsquo;27&#39;为ESC, ord(&lsquo;q&rsquo;) 检测按键q
cap.release() 程序结束后,释放摄像头
cap.get(3)# 宽度 cap.get(4) #高度 cap.get(5) # 视频的帧率 读取相机的相关数据 cv2.destroyAllWindows() 关闭所有创建的窗口
cv2.destroyWindow(window_name) # 关闭指定的窗口
保存相机捕获视频 # 创建windows编译解码器并创建VideoWriter对象 fourcc = cv2.VideoWriter_fourcc(*&#39;XVID&#39;) out = cv2.VideoWriter(&#39;output.avi&#39;, fourcc, fps(float), (width, height)) # 逐帧将图片写入out中 out.write(frame) out.release() # 释放文件资源 opencv 绘图功能 基本画图 cv2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liwei20001.github.io/post/test/" />
<meta property="article:published_time" content="2020-03-09T19:17:37+08:00" />
<meta property="article:modified_time" content="2020-03-09T19:17:37+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://liwei20001.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Test</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 9, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="opencv-pythonhttpsdocsopencvorgmasterd6d00tutorial_py_roothtml"><a href="https://docs.opencv.org/master/d6/d00/tutorial_py_root.html">opencv-python</a></h1>
<h2 id="图像初阶">图像初阶</h2>
<p><code>imread(filename, parameter)</code> parameter=1,加载彩色图像, parameter=0,加载灰度图像<br>
<code>imshow(window_name, img)</code> 显示图像<br>
<code>nameWindow(window_name, cv2.WINDOW_NORMAL)</code> 新建一个窗口, cv2.WINDOW_NORMAL: 窗口可调节, 默认不可调节<br>
<code>plt.imshow(img)</code> 在matplot中显示图像, <strong>matplotlib的图像通道为RGB而opencv的图像通道为BGR</strong></p>
<h2 id="视频入门">视频入门</h2>
<h3 id="从相机捕获视频">从相机捕获视频</h3>
<p><code>cap = cv2.Videocapture(0)</code> 调用摄像头,并创建摄像头对象<br>
<code>key = cv2.waitKey(0) &amp; 0xff</code> 按键检测, 返回一个int类型数据, &lsquo;27'为ESC, ord(&lsquo;q&rsquo;) 检测按键q<br>
<code>cap.release()</code> 程序结束后,释放摄像头<br>
<code>cap.get(3)# 宽度 cap.get(4) #高度 cap.get(5) # 视频的帧率</code> 读取相机的相关数据
<code>cv2.destroyAllWindows()</code> 关闭所有创建的窗口<br>
<code>cv2.destroyWindow(window_name)</code>  # 关闭指定的窗口</p>
<h3 id="保存相机捕获视频">保存相机捕获视频</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 创建windows编译解码器并创建VideoWriter对象</span>
fourcc <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>VideoWriter_fourcc(<span style="color:#f92672">*</span><span style="color:#e6db74">&#39;XVID&#39;</span>)
out <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>VideoWriter(<span style="color:#e6db74">&#39;output.avi&#39;</span>, fourcc, fps(float), (width, height)) 
<span style="color:#75715e"># 逐帧将图片写入out中</span>
out<span style="color:#f92672">.</span>write(frame)
out<span style="color:#f92672">.</span>release()  <span style="color:#75715e"># 释放文件资源</span>
</code></pre></div><h2 id="opencv-绘图功能">opencv 绘图功能</h2>
<h3 id="基本画图">基本画图</h3>
<p><code>cv2.line(img, start_point, end_point, (255, 255, 0), 3)</code> 图片, 起点, 终点, 颜色(BGR), 线宽<br>
<code>cv2.circle(img, 圆心(x, y), 半径, 颜色, -1)</code> 图片, 圆心, 半径, 颜色, 线宽(-1 表示填充圆)<br>
<code>cv2.rectangle(img, pt1, pt2, color, -1)</code> 图片, 左上角点, 右下角点, 颜色, 线宽(-1填充)<br>
<code>cv2.PutText(img, text, loc(tuple),  cv2.FONT_HERSHEY_COMPLEX, 4, (0, 0, 0), 2[, cv2.LINE_AA])</code> 图片, 文字, 位置, 字体, 大小, 颜色, 字体粗细, 文字类型<br>
<code>x, y, w, h = cv2.selectROI(img, False)</code>  选择ROI, 第二个参数为是否显示中心线, False为不显示</p>
<h3 id="鼠标作为控件画图">鼠标作为控件画图</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#%% 鼠标双击画图</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">draw_circle</span>(events, x, y, flags, parameter):  
	<span style="color:#66d9ef">if</span> events <span style="color:#f92672">==</span> cv2<span style="color:#f92672">.</span>EVENT_ LBUTTONDBLCLK:  <span style="color:#75715e"># 鼠标双击</span>
		cv2<span style="color:#f92672">.</span>circle(imag, (x, y), <span style="color:#ae81ff">100</span>, (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

imag <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(<span style="color:#ae81ff">512</span>,<span style="color:#ae81ff">512</span>,<span style="color:#ae81ff">3</span>, dtyep<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">’</span>uint8<span style="color:#960050;background-color:#1e0010">’</span>)
cv2<span style="color:#f92672">.</span>nameWindow(<span style="color:#960050;background-color:#1e0010">‘</span>imag<span style="color:#960050;background-color:#1e0010">’</span>)  <span style="color:#75715e">#拆创建一个名为imag的窗口</span>
cv2<span style="color:#f92672">.</span>setMouseCallback(<span style="color:#960050;background-color:#1e0010">‘</span>imag<span style="color:#960050;background-color:#1e0010">’</span>, draw_circle)  <span style="color:#75715e"># 对名为imag的窗口绑定draw_circle函数</span>
<span style="color:#66d9ef">while</span> True:
	cv2<span style="color:#f92672">.</span>imshow(<span style="color:#960050;background-color:#1e0010">‘</span>imag<span style="color:#960050;background-color:#1e0010">’</span>, imag)
	<span style="color:#66d9ef">if</span> cv2<span style="color:#f92672">.</span>waitKey(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">27</span>:
		<span style="color:#66d9ef">break</span>
cv2<span style="color:#f92672">.</span>destroyAllWindows()

<span style="color:#75715e">#%%鼠标按下, 确定矩形起点, 鼠标抬起确定矩形终点, 绘制矩形</span>
</code></pre></div><h3 id="用滑动条作为输入参数">用滑动条作为输入参数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">cv2<span style="color:#f92672">.</span>nameWindo(<span style="color:#e6db74">&#39;imag&#39;</span>, cv2<span style="color:#f92672">.</span>WINDOW_NORMAL)  <span style="color:#75715e"># 创建一个图形窗口</span>
cv2<span style="color:#f92672">.</span>createTrackbar(label, <span style="color:#e6db74">&#39;imag&#39;</span>, start(int), end(int), nothing)  <span style="color:#75715e"># 在名为&#39;imag&#39;的图形窗口创建一个名字为label的滑动条, 属性值在start到end之间变化, nothing为绑定的函数</span>
r <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>getTrackbarPos(label, <span style="color:#e6db74">&#39;imag&#39;</span>)  <span style="color:#75715e"># 返回该窗口的属性值</span>

</code></pre></div><h2 id="图像的基本处理">图像的基本处理</h2>
<h3 id="图像基本操作">图像基本操作</h3>
<p><code>img.item(row, col, ch)</code> 访问某个像素点的值<br>
<code>img.itemset((row, col, ch), val)</code>  设置某个像素点的值</p>
<h3 id="图像的算数运算">图像的算数运算</h3>
<h4 id="1图像融合">1.图像融合</h4>
<blockquote>
<p>当两个uint8的数进行加法运算时, opencv采用的是饱和运算, 即250+10 = 255, numpy 采用的是模运算, 即255+10 = 260/255 = 4</p>
</blockquote>
<p><code>cv2.addWeighted(img1, α, img2, β, γ)</code> 图像融合, img = img1<em>α + img2</em>β + γ <strong>只有两个大小相同的图像可以融合</strong></p>
<h4 id="2按位运算">2.按位运算</h4>
<p><code>cv2.bitwise_not(img)</code> 对二值图取反<br>
<code>cv2.bitwise_and(img, img, mask=二值化图像)</code> 图像与运算, 可用于提取图像的某一区域<br>
<code>cv2.bitwise_xor()</code> 异或</p>
<h4 id="3-图像减法">3. 图像减法</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">img1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(<span style="color:#ae81ff">10</span>, np<span style="color:#f92672">.</span>uint8)  <span style="color:#75715e"># 前景 </span>
img2 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(<span style="color:#ae81ff">255</span>, np<span style="color:#f92672">.</span>uint8)  <span style="color:#75715e"># 背景</span>

<span style="color:#75715e"># numpy减法</span>
img1 <span style="color:#f92672">-</span> img2 <span style="color:#75715e"># out: 11 (10-255 = -245 + 255 = 11)</span>
<span style="color:#75715e"># subtract 方法减法</span>
subtract(img1, img2)  <span style="color:#75715e"># out: 0 (10 - 255 = -245 = 0)</span>
<span style="color:#75715e"># absdiff减法</span>
absdiff(img1, img2)  <span style="color:#75715e"># out: 245 (10 - 255 = -245 ===&gt; abs(-245) = 245) </span>
</code></pre></div><blockquote>
<p>实测absdiff的去除背景的效果最好</p>
</blockquote>
<blockquote>
<p>sorted排序
sort(list_, key=fun, reversed=True|Flase) 对list_里的元素的进行排序, key为排序依据的键值, reversed表示是否反序(默认为升序)<br>
fun为一个函数, 返回排序依据的键值, 输入值为列表的每个元素<br>
fun也可为lambda函数:例如对列表按照列表的第二列进行排序:key=lambda d: d[1]</p>
</blockquote>
<h2 id="基于opencv的图像操作">基于opencv的图像操作</h2>
<h3 id="改变彩色空间">改变彩色空间</h3>
<p><code>cv2.cvtcolor(img, cv2.COLOR_BGRHSV)</code> 将BGR图转化为HSV图<br>
<code>cv2.COLOR_BGRGRAY</code> BGR转GRAY</p>
<p>###　缩放比例</p>
<h4 id="1缩放比例">1.缩放比例</h4>
<p><code>cv2.resize(img, none, fx=2, fy=2, interpolation=)</code> 按倍数放缩图像, <strong>插值方式</strong> : cv2.INTER_ARE&ndash;&gt;缩小, cv2.INTER_CUBIC&ndash;&gt;慢, cv2.INTER_LINEAR&ndash;&gt;用于缩放<br>
<code>cv2.resize(img, (x, y), interploration=)</code></p>
<h4 id="2矩阵变换">2.矩阵变换</h4>
<p><code>cv2.warAffine(img, M, (cols, rows))</code> 图像变换, cols, rows为返回矩阵的行数和列数, M为变换矩阵</p>
<ul>
<li>M = [1, 0, tx;0, 1, ty] 向x轴平移tx个单位, 向y轴平移ty个单位</li>
<li>M = cv2.getRotationMatrix2D(pt(tuple), angle(deg), scale) 将图像绕pt旋转angle, scale为缩放因子</li>
<li>M = cv2.getAffineTransform(pt1, pt2) 映射变换, pt1原图像的三个点(3,2的array), pt2新图像对应的三个点(3*2的array)</li>
</ul>
<h4 id="3透视变换">3.透视变换</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">M <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>getperspectiveTransform(pts1, pts2)  <span style="color:#75715e"># 构造变换矩阵, pts1的点为原图的四个点(4*2array), pts2为变换后的图像的对应的四个点(4*2array)</span>
cv2<span style="color:#f92672">.</span>warPerspective(img, M, (rows, cols)) <span style="color:#75715e"># 透视变换</span>
</code></pre></div><h4 id="4图像翻转">4.图像翻转</h4>
<p><code>cv2.flip(frame, flipcode=1)</code>: flipcode: 1&ndash;&gt;水平翻转  0&ndash;&gt;垂直翻转 -1&ndash;&gt;水平垂直翻转</p>
<h3 id="图像二值化">图像二值化</h3>
<blockquote>
<p>图像二值化后得到的不是Matlab的二进制图像, 数据类型依然为uint8</p>
</blockquote>
<h4 id="1简单阈值">1.简单阈值</h4>
<p><em><strong><code>ret, thresh = cv2.threshhold(img, 阈值, max, cv2.THRESH_BINARY)</code></strong></em> 图像二值化<br>
<code>ret，thresh2 = cv2.threshold（img，127,255，cv2.THRESH_BINARY_INV)</code>图像二值化, 灰度值大于127的为取为二进制数0,, 灰度值小于127取为二进制数1<br>
<code>ret，thresh3 = cv2.threshold(img，127,255，cv2.THRESH_TRUNC)</code> 提高灰度图对比度<br>
<code>ret，thresh4 = cv2.threshold(img，127,255，cv.THRESH_TOZERO)</code> 将灰度图小于阈值的灰度值令为0, 即显示为黑色<br>
<code>ret，thresh5 = cv2.threshold(img，127,255，cv2.THRESH_TOZERO_INV)</code> 将灰度图大于阈值的图像令为0, 即显示为黑色</p>
<h4 id="2自适应阈值">2.自适应阈值</h4>
<p><code>img = cv2.adaptiveThreshold(img, 255(max), cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY, blocksize(int), c(int))</code>  均值自适应阈值, blocksize为选择的区块大小, c为一个常数用于补偿处理后的矩阵<br>
<code>img = cv2.adaptiveThreshold(img, 255(max), cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY, blocksize(int), c(int))</code>  高斯自适应阈值, blocksize为选择的区块大小, c为一个常数用于补偿处理后的矩阵</p>
<h4 id="3ostu二值化使用于不止一个峰值的图像的二值化">3.Ostu二值化(使用于不止一个峰值的图像的二值化)</h4>
<p><code>ret， thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OSTU)</code></p>
<h3 id="平滑图像">平滑图像</h3>
<h4 id="2d卷积">2D卷积</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">core <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>ones((<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>))<span style="color:#f92672">/</span><span style="color:#ae81ff">9</span>  <span style="color:#75715e"># 2D卷积核</span>
cv2<span style="color:#f92672">.</span>filter2D(img, deepth(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), core)  <span style="color:#75715e"># 使用core对图像进行2D卷积, deepth为深度 </span>
</code></pre></div><h4 id="图像模糊">图像模糊</h4>
<p><code>cv2.blur(img, (5, 5))</code>  均值图像模糊<br>
<code>cv2.medianBlur(img, 5)</code>  中位数图像模糊<br>
<code>cv2.GuassianBlur(img, (5,5), γ(uint8))</code> 高斯模糊, (5,5) 为卷积核大小, γ为增益<br>
<code>cv2.bliateFilter(img, 9.75, 7.5)</code> 双边过滤</p>
<h3 id="图像形态学形态转化">图像形态学(形态转化)</h3>
<h4 id="1侵蚀根据内核大小-将边界附近的所有元素都丢弃掉-减小前景对象的厚度前景为白色-若前景为黑色-bitwise_not反转前后景的颜色或用扩张代替">1.侵蚀:根据内核大小, 将边界附近的所有元素都丢弃掉, 减小前景对象的厚度(前景为白色, 若前景为黑色, bitwise_not反转前后景的颜色或用扩张代替)</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">kernel <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>ones((<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>), np<span style="color:#f92672">.</span>uint8)  <span style="color:#75715e"># 创建一个内核</span>
erode <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>erode(img, kernel, iteration<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># 腐蚀</span>
</code></pre></div><h4 id="2膨胀根据内核的大小-增加前景边界附近的元素-增大前景对象的厚度-默认前景对象为白色">2.膨胀:根据内核的大小, 增加前景边界附近的元素, 增大前景对象的厚度, 默认前景对象为白色</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">kernel <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>ones((<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>), dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>uint8)  <span style="color:#75715e"># 创建内核</span>
dilation <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>dilate(img, kernel, iteration<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># 膨胀</span>
</code></pre></div><h4 id="3开运算-先腐蚀后膨胀的-消除背景的噪点背景为黑色">3.开运算: 先腐蚀后膨胀的, 消除背景的噪点(背景为黑色)</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">kernel <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>ones((<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>), dtype<span style="color:#f92672">=</span>uint8)  <span style="color:#75715e"># 创建内核</span>
openning <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>morphologyEx(img, cv2<span style="color:#f92672">.</span>MORPH_OPEN, kernel)  <span style="color:#75715e"># 开运算 </span>
</code></pre></div><h4 id="4闭运算-先膨胀后腐蚀运算-消除前景内的噪点前景为白色">4.闭运算: 先膨胀后腐蚀运算, 消除前景内的噪点(前景为白色)</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">kernel <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>ones((<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>), dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>uint8)  <span style="color:#75715e">#创建内核</span>
closing <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>morphologyEx(img, cv2<span style="color:#f92672">.</span>MORPH_CLOSE, kernel)  <span style="color:#75715e"># 闭运算</span>
</code></pre></div><h4 id="5形态梯度-膨胀与腐蚀的区别-其结果相当于得到图像的轮廓">5.形态梯度, 膨胀与腐蚀的区别, 其结果相当于得到图像的轮廓</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">kernel <span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>ones((<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>), dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>uint8)  <span style="color:#75715e"># 创建内核</span>
gradient <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>morphologyEx(img, cv2<span style="color:#f92672">.</span>MORPH_GRADIENT, kernel)  <span style="color:#75715e"># 形态梯度</span>
</code></pre></div><h4 id="6top_hat-原图像与图像开运算先腐蚀-再膨胀的区别">6.TOP_HAT: 原图像与图像开运算(先腐蚀, 再膨胀)的区别</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">kernel <span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>ones((<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>), dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>uint8)  <span style="color:#75715e"># 创建内核</span>
tophat <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>morphologyEx(img, cv2<span style="color:#f92672">.</span>MORPH_TOPHAT, kernel)  <span style="color:#75715e"># 顶帽</span>
</code></pre></div><h4 id="7black_hat-原图像与图像闭运算先膨胀-后腐蚀的区别">7.Black_HAT: 原图像与图像闭运算(先膨胀, 后腐蚀)的区别</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">kernel <span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>ones((<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>), dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>uint8)  <span style="color:#75715e"># 创建内核</span>
tophat <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>morphologyEx(img, cv2<span style="color:#f92672">.</span>MORPH_BLACKPHAT, kernel)  <span style="color:#75715e"># 黑帽</span>
</code></pre></div><h2 id="图像梯度">图像梯度</h2>
<p>###　sobel算子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># cv2.CV_64F 出图像的深度 数据类型 可以使用 -1, 与原图像保持一致 np.uint8</span>
laplacian <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>Laplacian(img, cv2<span style="color:#f92672">.</span>CV_64F)  <span style="color:#75715e"># 求二阶导数  </span>
<span style="color:#75715e"># 参数 1,0 为只在 x 方向求一 导数 最大可以求 2 导数。</span>
sobelx <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>Sobel(img, cv2<span style="color:#f92672">.</span>CV_64F, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, ksize<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)  <span style="color:#75715e"># 1, 0 = dx, dy</span>
<span style="color:#75715e"># 参数 0,1 为只在 y 方向求一 导数 最大可以求 2 导数。</span>
sobely <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>Sobel(img, cv2<span style="color:#f92672">.</span>CV_64F, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, ksize<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)
</code></pre></div><h2 id="canny边缘检测">Canny边缘检测</h2>
<p><code>edges = cv2.Canny(img, 100, 200)</code> 100:threshhold1, 200: threshold2</p>
<h2 id="绘制轮廓">绘制轮廓</h2>
<p><code>cnts, hierarchy = cv2.findContours(img, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</code> img为二值图cnts为轮廓, hierarchy为轮廓的信息<br>
<code>cv2.drawcontours(img, cnts, pra, color, linewidth)</code></p>
<ul>
<li>img:绘制轮廓的图像, 注意该函数不反返回任何值</li>
<li>cnts: findContours返回的轮廓</li>
<li>pra: 1表示绘制第2个轮廓, -1:绘制cnts中的所有轮廓</li>
<li>color: 轮廓颜色(0, 255, 0)</li>
<li>linewidth: 线宽(int)</li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
